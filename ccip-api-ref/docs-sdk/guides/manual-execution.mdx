---
id: manual-execution
title: 'Manual Execution'
description: 'Manually execute CCIP messages when automatic execution fails or is delayed.'
sidebar_label: Manual Execution
sidebar_position: 6
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Manual Execution

When automatic CCIP message execution fails on the destination chain, you can manually execute the message. This guide covers the complete workflow for manual execution.

## When to Manually Execute

Manual execution is needed when:

- **Receiver contract reverts** - The destination contract throws an error
- **Insufficient gas limit** - The gas limit set in extraArgs was too low
- **Rate limiter blocked** - Token transfer exceeded rate limits
- **Execution timeout** - Automatic execution window expired

## Prerequisites

Before manual execution, ensure:

1. The message has been **committed** on the destination chain
2. The **source chain finality** period has passed
3. You have a funded **wallet** on the destination chain

## Simplified Workflow (Message ID)

If you have the CCIP message ID and the API is available (default), you can skip the source chain entirely:

```typescript
import { EVMChain } from '@chainlink/ccip-sdk'

const dest = await EVMChain.fromUrl('https://rpc.fuji.avax.network')

const execution = await dest.execute({
  messageId: '0x1234...', // CCIP message ID (32-byte hex)
  wallet: destWallet,
})

console.log('Execution tx:', execution.log.transactionHash)
```

This delegates proof calculation and offchain token data fetching to the CCIP API, removing the need for source chain RPC access.

## Step-by-Step Workflow (Transaction Hash)

### Step 1: Get the Original Request

Retrieve the message from the source chain transaction:

```typescript
import { EVMChain } from '@chainlink/ccip-sdk'

const source = await EVMChain.fromUrl('https://rpc.sepolia.org')
const dest = await EVMChain.fromUrl('https://rpc.fuji.avax.network')

const sourceTxHash = '0x1234...' // Transaction that sent the CCIP message

// getMessagesInTx throws CCIPMessageNotFoundInTxError if no messages found
const requests = await source.getMessagesInTx(sourceTxHash)
const request = requests[0]
console.log('Message ID:', request.message.messageId)
console.log('Sequence Number:', request.message.sequenceNumber)
```

### Step 2: Find the OffRamp Contract

Discover the OffRamp contract on the destination chain:

```typescript
import { discoverOffRamp } from '@chainlink/ccip-sdk'

const offRamp = await discoverOffRamp(source, dest, request.lane.onRamp)
console.log('OffRamp address:', offRamp)
```

### Step 3: Check Execution Status

Verify whether the message needs manual execution:

```typescript
import { ExecutionState } from '@chainlink/ccip-sdk'

let needsManualExecution = true

for await (const execution of dest.getExecutionReceipts({
  offRamp,
  messageId: request.message.messageId,
})) {
  console.log('Execution state:', execution.receipt.state) // 1=InProgress, 2=Success, 3=Failed

  switch (execution.receipt.state) {
    case ExecutionState.Success:
      console.log('Message already executed successfully')
      needsManualExecution = false
      break

    case ExecutionState.Failed:
      console.log('Previous execution failed')
      console.log('Return data:', execution.receipt.returnData)
      // Can proceed with manual execution
      break

    case ExecutionState.InProgress:
      console.log('Execution in progress')
      // Wait and check again
      break
  }
}

if (!needsManualExecution) {
  process.exit(0)
}
```

### Step 4: Get the Verifications

Verify the message has been committed:

```typescript
let verifications
try {
  verifications = await dest.getVerifications({
    offRamp,
    request,
  })
} catch (error) {
  // getVerifications throws CCIPCommitNotFoundError (transient) when not yet committed
  console.log('Message not yet committed')
  console.log('Wait for the DON to commit the merkle root')
  process.exit(1)
}

console.log('Commit found!')
console.log('Merkle root:', verifications.report.merkleRoot)
console.log('Min sequence:', verifications.report.minSeqNr)
console.log('Max sequence:', verifications.report.maxSeqNr)
console.log('Commit tx:', verifications.log.transactionHash)
```

### Step 5: Fetch Execution Inputs and Calculate Proof

Get execution input and calculate proofs:

```typescript
const input = await source.getExecutionInput({ request, verifications })

console.log('Calculated proof:', input.merkleRoot)
console.log('Offchain tokenData:', input.offchainTokenData)
```

### Step 6: Execute the Report

Submit the manual execution transaction:

```typescript
const execution = await dest.execute({
  offRamp,
  input,
  wallet: destWallet,
})

console.log('Manual execution submitted:', execution.log.transactionHash)
console.log('Execution confirmed in block:', execution.log.blockNumber)
```

## Complete Example (Message ID)

```typescript
import { ethers } from 'ethers'
import { EVMChain } from '@chainlink/ccip-sdk'

async function manuallyExecuteByMessageId(
  destRpc: string,
  messageId: string,
  wallet: ethers.Signer
) {
  const dest = await EVMChain.fromUrl(destRpc)

  const execution = await dest.execute({ messageId, wallet })

  console.log('Manual execution tx:', execution.log.transactionHash)
  return { status: 'executed', txHash: execution.log.transactionHash }
}

// Usage
const destProvider = new ethers.JsonRpcProvider('https://rpc.fuji.avax.network')
const destWallet = new ethers.Wallet(process.env.DEST_PRIVATE_KEY!, destProvider)

await manuallyExecuteByMessageId(
  'https://rpc.fuji.avax.network',
  '0xYourMessageId...',
  destWallet
)
```

## Complete Example (Transaction Hash)

```typescript
import { ethers } from 'ethers'
import {
  EVMChain,
  discoverOffRamp,
  ExecutionState,
} from '@chainlink/ccip-sdk'

async function manuallyExecuteMessage(
  sourceRpc: string,
  destRpc: string,
  sourceTxHash: string,
  wallet: ethers.Signer
) {
  // Connect to chains
  const source = await EVMChain.fromUrl(sourceRpc)
  const dest = await EVMChain.fromUrl(destRpc)

  // Step 1: Get the request (throws CCIPMessageNotFoundInTxError if not found)
  const requests = await source.getMessagesInTx(sourceTxHash)
  const request = requests[0]
  console.log('Processing message:', request.message.messageId)

  // Step 2: Find OffRamp
  const offRamp = await discoverOffRamp(source, dest, request.lane.onRamp)

  // Step 3: Check if already executed
  for await (const execution of dest.getExecutionReceipts({
    offRamp,
    messageId: request.message.messageId,
  })) {
    if (execution.receipt.state === ExecutionState.Success) {
      console.log('Already executed')
      return { status: 'already_executed' }
    }
  }

  // Step 4: Get commit (throws CCIPCommitNotFoundError if not yet committed)
  let verifications
  try {
    verifications = await dest.getVerifications({ offRamp, request })
  } catch (error) {
    console.log('Not yet committed')
    return { status: 'pending_commit' }
  }

  // Step 5: Get messages in batch
  const input = await source.getExecutionInput({ request, verifications })

  // Step 6: Execute
  const execution = await dest.execute({
    offRamp,
    input,
    wallet,
  })

  console.log('Manual execution tx:', execution.log.transactionHash)
  return { status: 'executed', txHash: execution.log.transactionHash }
}

// Usage
const destProvider = new ethers.JsonRpcProvider('https://rpc.fuji.avax.network')
const destWallet = new ethers.Wallet(process.env.DEST_PRIVATE_KEY!, destProvider)

await manuallyExecuteMessage(
  'https://rpc.sepolia.org',
  'https://rpc.fuji.avax.network',
  '0xSourceTxHash...',
  destWallet
)
```

## Handling Token Transfers

For messages with token transfers, you may need offchain token data:

### USDC (CCTP) Transfers

For USDC transfers using CCTP, you need to fetch the Circle attestation. The SDK handles this automatically:

```typescript
// Fetch offchain token data (handles USDC attestations automatically)
const input = await source.getExecutionInput({ request, verifications })
console.log('offchainTokenData:', input.offchainTokenData)

const execution = await dest.execute({
  offRamp,
  input,
  wallet: destWallet,
})
```

### Standard Token Transfers

For non-CCTP tokens, `offchainTokenData` is typically empty:

```typescript
// getExecutionInput handles standard tokens automatically (empty offchainTokenData)
const input = await source.getExecutionInput({ request, verifications })

const execution = await dest.execute({
  offRamp,
  input,
  wallet: destWallet,
})
```

## Troubleshooting

### Execution Reverts

If manual execution reverts, check:

1. **Gas limit** - Increase gas for the destination execution
2. **Receiver contract** - Ensure the receiver can handle the message
3. **Token allowances** - Verify token pool has sufficient liquidity

```typescript
// Increase gas limit for execution
const execution = await dest.execute({
  offRamp,
  input,
  wallet: destWallet,
  gasLimit: 500000, // Override gas limit
})
```

### Message Not Found

If the message isn't found on the source chain:

```typescript
import { networkInfo } from '@chainlink/ccip-sdk'

// Verify you're on the correct source chain
const sourceNetwork = networkInfo(source.network.chainSelector)
console.log('Source chain:', sourceNetwork.name)

// Check if the transaction hash is correct
const tx = await source.getTransaction(sourceTxHash)
if (!tx) {
  console.log('Transaction not found - verify the hash and chain')
}
```

## Using the CLI

The CLI provides a simpler interface for manual execution:

```bash
# Execute by transaction hash (needs source + dest RPCs)
ccip-cli manual-exec 0xSourceTxHash \
  --rpc https://rpc.sepolia.org \
  --rpc https://rpc.fuji.avax.network \
  --wallet $PRIVATE_KEY

# Execute by message ID (only needs dest chain RPC)
ccip-cli manual-exec 0xMessageId \
  --rpc https://rpc.fuji.avax.network \
  --wallet $PRIVATE_KEY
```

See [CLI Manual Exec](/cli/manual-exec) for more options.

## Related

- [Error Handling](/sdk/guides/error-handling) - Error types and recovery
- [Tracking Messages](/sdk/guides/tracking-messages) - Monitor message status
- [CLI Manual Exec](/cli/manual-exec) - Command-line manual execution
